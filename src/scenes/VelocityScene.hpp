#ifndef VELOCITYSCENE_HPP
#define VELOCITYSCENE_HPP

#include "../core/Scene.hpp"
#include "../core/JointVelocityConstraint.hpp"
#include "../core/CartesianVelocityConstraint.hpp"

namespace wbc{

typedef std::shared_ptr<CartesianVelocityConstraint> CartesianVelocityConstraintPtr;
typedef std::shared_ptr<JointVelocityConstraint> JointVelocityConstraintPtr;

class VelocityScene : public WbcScene{
protected:
    base::VectorXd solver_output_vel, robot_vel;
    /**
     * @brief Create a constraint and add it to the WBC scene
     */
    virtual ConstraintPtr createConstraint(const ConstraintConfig &config);

public:
    VelocityScene(RobotModelPtr robot_model, QPSolverPtr solver) :
        WbcScene(robot_model, solver){}
    virtual ~VelocityScene(){
    }

    /**
     * @brief Update the wbc scene
     */
    virtual const HierarchicalQP& update();

    /**
     * @brief Solve the given optimization problem
     *  \f[
     *     \left(\begin{array}{cc} \omega \\ v \end{array}\right)_B = \left(\begin{array}{cc} R & 0 \\ \left[p\right]R & R \end{array}\right) \left(\begin{array}{cc} \omega \\ v \end{array}\right)_A
     *  \f]
     *
     * @return Solver output as joint velocity command
     */
    virtual const base::commands::Joints& solve(const HierarchicalQP& hqp);

    /**
     * @brief Compute y and y_solution for each constraint. y_solution denotes the constraint velocity that can be achieved
     *  with the solution generated by the solver and y denotes the actual joint velocity achieved by the robot.
     *  Both values can be used to evaluate the performance of WBC
     */
    virtual const ConstraintsStatus &updateConstraintsStatus();
};

} // namespace wbc

#endif
